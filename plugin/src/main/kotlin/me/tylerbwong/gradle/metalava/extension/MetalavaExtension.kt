package me.tylerbwong.gradle.metalava.extension

import me.tylerbwong.gradle.metalava.Format
import me.tylerbwong.gradle.metalava.Signature
import org.gradle.api.JavaVersion
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.RegularFile
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.provider.SetProperty
import javax.inject.Inject

open class MetalavaExtension @Inject constructor(
    objectFactory: ObjectFactory,
) {
    /**
     * The version of Metalava to use.
     */
    val version: Property<String> = objectFactory.property<String>().also { it.set("1.0.0-alpha10") }

    /**
     * A custom Metalava JAR location path to use instead of the embedded dependency.
     */
    val metalavaJarPath: Property<String> = objectFactory.property { set("") }

    /**
     * Sets the source level for Java source files; default is 17.
     */
    val javaSourceLevel: Property<JavaVersion> = objectFactory.property {
        set(JavaVersion.VERSION_17)
    }

    /**
     * @see Format
     */
    val format: Property<Format> = objectFactory.property { set(Format.V4) }

    /**
     * @see Signature
     */
    val signature: Property<Signature> = objectFactory.property { set(Signature.API) }

    /**
     * The final descriptor file output name.
     */
    val filename: Property<String> = objectFactory.property { set("api.txt") }

    /**
     *  Type is one of 'api' and 'removed', which checks either the public api or the removed api.
     */
    val apiType: Property<String> = objectFactory.property { set("api") }

    /**
     * Remove the given packages from the API even if they have not been marked with @hide.
     */
    val hiddenPackages: SetProperty<String> = objectFactory.setProperty()

    /**
     * Treat any elements annotated with the given annotation as hidden.
     */
    val hiddenAnnotations: SetProperty<String> = objectFactory.setProperty()

    /**
     * Whether the signature file being read should be interpreted as having encoded its types using
     * Kotlin style types: a suffix of "?" for nullable types, no suffix for non nullable types, and
     * "!" for unknown. The default is false.
     */
    val inputKotlinNulls: Property<Boolean> = objectFactory.property { set(false) }

    /**
     * Promote all warnings to errors.
     */
    val reportWarningsAsErrors: Property<Boolean> = objectFactory.property { set(false) }

    /**
     * Promote all API lint warnings to errors.
     */
    val reportLintsAsErrors: Property<Boolean> = objectFactory.property { set(false) }

    /**
     * Additional directories to search for source files. An exception will be thrown if the named
     * directories are not direct children of the project root.
     *
     * By default, Metalava will automatically detect the source sets of the project,
     * excluding test sources.
     */
    val additionalSourceSets: ConfigurableFileCollection = objectFactory.fileCollection()

    /**
     * If the tasks should run as part of Gradle's `check` task. The default is true.
     */
    val enforceCheck: Property<Boolean> = objectFactory.property { set(true) }

    /**
     * Generate a file with keep rules at the specified location. The default is `null` which will
     * cause no keep file to be generated.
     */
    val keepFilename: Property<String?> = objectFactory.property { set(null) }

    /**
     * Internal setter for `outputSignatureFileProvider`.
     *
     * @see outputSignatureFileProvider
     */
    internal val outputSignatureFileProperty: Property<RegularFile> = objectFactory.fileProperty()

    /**
     * A provider for the signature file generated by Metalava.
     *
     * Using this as an input to a task will run the generate signature task and generate a
     * signature file.
     */
    val outputSignatureFileProvider: Provider<RegularFile> = outputSignatureFileProperty

    private inline fun <reified T> ObjectFactory.property(
        configuration: Property<T>.() -> Unit = {},
    ): Property<T> = property(T::class.java).apply { configuration() }

    private inline fun <reified T> ObjectFactory.setProperty(
        configuration: SetProperty<T>.() -> Unit = {},
    ): SetProperty<T> = setProperty(T::class.java).apply { configuration() }
}
